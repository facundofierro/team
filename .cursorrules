# TeamHub Cursor Rules

## Project Overview
TeamHub is an enterprise AI agent management platform built with Next.js 14, TypeScript, and a modern monorepo structure. It provides multi-tenant environments for organizations to create, manage, and orchestrate AI agents at scale.

## Architecture Guidelines

### Monorepo Structure
- Use `pnpm` for package management across the monorepo
- Follow the established folder structure: `apps/`, `packages/`, `infrastructure/`, `docs/`
- Each package should have clear responsibilities and minimal dependencies
- Use Turbo for build orchestration and caching

### Applications
- **teamhub**: Main Next.js application (UI + API)
- **ai-gateway**: AI provider abstraction service
- **browser-service**: Automated browser control (currently disabled due to Playwright build issues)

### Packages
- **teamhub-ai**: AI functions, tools, and agent communication
- **teamhub-db**: Database schemas, ORM functions, and data access
- **ai-services**: Multi-provider AI service abstractions

## Technology Stack Conventions

### Frontend (Next.js 14)
- Use App Router exclusively (no Pages Router)
- Prefer Server Components when possible, use Client Components only when necessary
- Always mark Client Components with `'use client'` directive
- Use TypeScript strictly - no `any` types without justification
- Follow shadcn/ui component patterns and naming conventions

### UI/UX Standards
- Use shadcn/ui components exclusively for consistency
- Follow the established color scheme: `bg-menu`, `bg-menu2`, `bg-background`, etc.
- Implement responsive design with mobile-first approach
- Use Tailwind CSS classes consistently
- Maintain accessibility standards (ARIA labels, keyboard navigation)

### State Management
- Use Zustand for client-side state management
- Keep stores focused and minimal (agentStore, organizationStore, navigationStore)
- Avoid prop drilling - use stores for shared state
- Server state should be managed separately from client state

### Database & ORM
- Use Drizzle ORM exclusively for database operations
- All database functions should be in `packages/teamhub-db`
- Follow type-safe query patterns
- Use transactions for multi-table operations
- Implement proper error handling and validation

### AI Integration
- All AI provider interactions should go through `packages/ai-services`
- Support multiple providers: OpenAI, DeepSeek, Fal, Eden AI
- Implement streaming responses where possible
- Handle region restrictions gracefully (especially for OpenAI embeddings)
- Use the established tool framework for new integrations

## Code Style & Quality

### TypeScript
- Enable strict mode and all strict checks
- Use proper type definitions - avoid `any`
- Prefer interfaces over types for object shapes
- Use generic types for reusable components
- Export types alongside implementations

### File Organization
- Use kebab-case for file names
- Group related components in directories
- Index files should re-export main components
- Keep components focused and single-responsibility
- Use meaningful, descriptive names

### Naming Conventions
- Components: PascalCase (e.g., `AgentDetail`, `ChatCard`)
- Functions: camelCase (e.g., `sendChat`, `getAgents`)
- Constants: SCREAMING_SNAKE_CASE (e.g., `API_ENDPOINTS`)
- Files: kebab-case (e.g., `agent-detail.tsx`, `chat-card.tsx`)
- Database entities: camelCase in code, snake_case in database

### Error Handling
- Always handle errors gracefully
- Use try-catch blocks for async operations
- Provide meaningful error messages to users
- Log errors appropriately with context
- Implement proper fallbacks and loading states

## Component Guidelines

### React Components
- Use functional components exclusively
- Implement proper loading and error states
- Use React.memo() for expensive computations
- Prefer composition over inheritance
- Keep components under 200 lines when possible

### Props & Types
- Define explicit prop interfaces
- Use optional props with default values
- Implement prop validation with TypeScript
- Document complex props with JSDoc comments
- Avoid passing entire objects when specific props will do

### Hooks
- Use built-in hooks appropriately
- Create custom hooks for reusable logic
- Keep hooks focused and testable
- Follow hooks rules (always call at top level)
- Use dependency arrays correctly in useEffect

## API & Server Actions

### Server Actions
- Use Server Actions for mutations (create, update, delete)
- Implement proper validation using Zod or similar
- Handle authentication and authorization
- Return typed responses
- Use revalidatePath/revalidateTag appropriately

### API Routes
- Use API routes for external integrations
- Implement proper error handling and status codes
- Use middleware for authentication
- Document API endpoints
- Follow RESTful conventions where applicable

### Database Operations
- Use organization-scoped queries for multi-tenancy
- Implement proper pagination for large datasets
- Use database transactions for consistency
- Handle unique constraints and conflicts
- Optimize queries for performance

## Security Guidelines

### Authentication & Authorization
- Use NextAuth.js for authentication
- Implement proper session management
- Check permissions on all protected routes
- Validate user access to organizations
- Use environment variables for secrets

### Data Protection
- Implement organization-level data isolation
- Validate all input data
- Sanitize user-generated content
- Use parameterized queries to prevent SQL injection
- Implement rate limiting where appropriate

### Environment Variables
- Use `.env.local` for development
- Never commit secrets to version control
- Use GitHub Secrets for production
- Validate required environment variables at startup
- Provide meaningful defaults where possible

## AI & Tools Development

### Tool Creation
- Implement the `ToolTypeDefinition` interface
- Use Zod schemas for parameter validation
- Include proper error handling and timeouts
- Test tools thoroughly before deployment
- Document tool capabilities and limitations

### AI Provider Integration
- Follow the established provider abstraction pattern
- Implement both generation and discovery functions
- Handle provider-specific errors gracefully
- Support streaming where available
- Test with multiple providers

### Memory Management
- Use semantic search with pgvector when possible
- Implement proper memory categorization
- Handle embedding generation failures gracefully
- Respect retention policies and cleanup old data
- Optimize memory retrieval performance

## Testing Guidelines

### End-to-End Testing
- Use Playwright for E2E tests
- Test critical user flows
- Include authentication in test setup
- Use page object models for maintainability
- Run tests in CI/CD pipeline

### Unit Testing
- Test complex business logic
- Mock external dependencies
- Use descriptive test names
- Keep tests focused and isolated
- Maintain good test coverage

## Deployment & Infrastructure

### Docker
- Use multi-stage builds for optimization
- Prefer distroless images for security
- Minimize image size (target < 200MB)
- Use proper health checks
- Handle graceful shutdowns

### Environment Management
- Use Docker Swarm for orchestration
- Implement selective service redeployment
- Use secrets management for sensitive data
- Monitor service health
- Implement proper logging

### CI/CD
- Use GitHub Actions for automation
- Run tests before deployment
- Build and push to GitHub Container Registry
- Implement automated rollbacks
- Monitor deployment success

## Performance Guidelines

### Frontend Performance
- Use React.memo() for expensive components
- Implement proper loading states
- Optimize images and assets
- Use code splitting where appropriate
- Monitor bundle size

### Database Performance
- Use indexes appropriately
- Implement query optimization
- Use connection pooling
- Monitor query performance
- Implement proper caching strategies

### Caching
- Use Redis for application caching
- Implement proper cache invalidation
- Cache expensive computations
- Use browser caching for static assets
- Monitor cache hit rates

## Documentation Standards

### Code Documentation
- Use JSDoc for complex functions
- Document API endpoints thoroughly
- Keep README files up to date
- Include examples in documentation
- Document breaking changes

### Architecture Documentation
- Keep architecture diagrams current
- Document deployment procedures
- Maintain troubleshooting guides
- Document environment setup
- Include performance considerations

## Common Patterns

### Database Queries
```typescript
// Use organization-scoped queries
const agents = await db.getAgents(organizationId)

// Use transactions for multiple operations
await db.transaction(async (tx) => {
  await tx.insert(agents).values(newAgent)
  await tx.insert(agentPermissions).values(permissions)
})
```

### Error Handling
```typescript
try {
  const result = await riskOperation()
  return { success: true, data: result }
} catch (error) {
  console.error('Operation failed:', error)
  return { success: false, error: 'Operation failed' }
}
```

### Component Structure
```typescript
interface ComponentProps {
  required: string
  optional?: boolean
}

export function Component({ required, optional = false }: ComponentProps) {
  // Implementation
}
```

### Tool Implementation
```typescript
export const myTool: ToolTypeDefinition = {
  id: 'myTool',
  type: 'myTool',
  description: 'Tool description',
  parametersSchema: z.object({
    param: z.string().describe('Parameter description')
  }),
  handler: async (params, configuration) => {
    // Tool logic
  }
}
```

## Debugging & Troubleshooting

### Logging
- Use structured logging with context
- Include operation IDs for tracing
- Log errors with stack traces
- Use appropriate log levels
- Include timing information

### Development Tools
- Use React DevTools for component debugging
- Use Drizzle Studio for database inspection
- Use browser DevTools for performance profiling
- Use TypeScript strict mode for better error detection
- Use ESLint and Prettier for code quality

### Common Issues
- Playwright build issues: Browser service currently disabled
- OpenAI embedding region restrictions: Implement fallbacks
- Database connection issues: Check environment variables
- Authentication issues: Verify ALLOWED_EMAILS configuration
- Memory issues: Monitor conversation memory growth

Remember: This is an enterprise platform - prioritize security, performance, and maintainability in all decisions.
