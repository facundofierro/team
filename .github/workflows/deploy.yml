name: Deploy to Self-Hosted Server

on:
  push:
    branches:
      - main

jobs:
  prepare-tag:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set_tag.outputs.tag }}
    steps:
      - name: Set commit SHA as output
        id: set_tag
        run: echo "tag=${GITHUB_SHA}" >> $GITHUB_OUTPUT

  setup-registry:
    runs-on: self-hosted
    needs: prepare-tag
    steps:
      - name: Checkout only required files
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-stack.yml
            setup-registry.sh
            nginx-infra.conf
          sparse-checkout-cone-mode: false

      - name: Ensure Pinggy tunnel is running BEFORE infrastructure
        run: |
          # Single tunnel with wildcard domain forwarding
          if ! docker ps --filter "name=pinggy-tunnel" --filter "status=running" --format "{{.Names}}" | grep -q "^pinggy-tunnel$"; then
            echo "Wildcard tunnel not running, setting it up..."
            docker stop pinggy-tunnel 2>/dev/null || true
            docker rm pinggy-tunnel 2>/dev/null || true
            # Single tunnel through nginx reverse proxy
            # All services accessible through port 80 with path-based routing
            docker run --net=host --name=pinggy-tunnel -d pinggy/pinggy \
              -p 443 \
              -R0:127.0.0.1:80 \
              -o StrictHostKeyChecking=no -o ServerAliveInterval=30 \
              FpyP2PGUXy0@pro.pinggy.io
            echo "Waiting for wildcard tunnel to be ready..."
            sleep 15

            # Show tunnel information
            echo "Tunnel logs:"
            docker logs pinggy-tunnel 2>/dev/null | tail -20 || echo "No logs available yet"

            echo "Waiting additional time for all ports to be mapped..."
            sleep 10
            echo "Final tunnel status:"
            docker logs pinggy-tunnel 2>/dev/null | tail -30 || echo "No logs available yet"
          else
            echo "Wildcard Pinggy tunnel is already running."
          fi

          # Clean up any orphaned pinggy containers (containers without proper names)
          echo "Cleaning up orphaned pinggy containers..."
          docker ps -a --filter "ancestor=pinggy/pinggy" --format "{{.Names}}" | grep -v -E "^pinggy-tunnel$" | xargs -r docker rm -f

      - name: Deploy infrastructure services (nginx + registry)
        run: |
          # Check if teamhub image already exists in registry
          echo "Checking if teamhub image exists in registry..."
          TEAMHUB_EXISTS=false
          if curl -f -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/teamhub/tags/list 2>/dev/null | grep -q "latest"; then
            echo "âœ… Teamhub image already exists in registry"
            TEAMHUB_EXISTS=true
          else
            echo "â„¹ï¸ Teamhub image not found in registry - first deployment"
          fi

          # Check if full stack is already deployed
          FULL_STACK_EXISTS=false
          if docker service ls --filter name=teamhub_teamhub --format "{{.Name}}" | grep -q teamhub_teamhub; then
            echo "âœ… Full stack already deployed"
            FULL_STACK_EXISTS=true
          fi

          # Only deploy infrastructure if teamhub image doesn't exist and full stack isn't deployed
          if [ "$TEAMHUB_EXISTS" = false ] && [ "$FULL_STACK_EXISTS" = false ]; then
            echo "ðŸš€ Deploying infrastructure services (nginx + registry) for first time..."

            # Check if registry volumes exist
            if ! docker volume ls --filter name=registry_data --format "{{.Name}}" | grep -q registry_data; then
              echo "Registry volumes not found. Running setup script..."
              chmod +x setup-registry.sh
              ./setup-registry.sh
            fi

            # Use existing nginx-infra.conf file (no need to create it)

            # Create a temporary stack file with only infrastructure services
            cat > docker-stack-infra.yml << 'EOF'
          version: '3.8'
          services:
            nginx:
              image: nginx:alpine
              deploy:
                replicas: 1
              ports:
                - '80:80'
                - '443:443'
              configs:
                - source: nginx_infra_config
                  target: /etc/nginx/nginx.conf
              networks:
                - registry_network

            registry:
              image: registry:2
              deploy:
                replicas: 1
                placement:
                  constraints:
                    - node.role == manager
              expose:
                - "5000"
              environment:
                - REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/var/lib/registry
                - REGISTRY_AUTH=htpasswd
                - REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm
                - REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd
              volumes:
                - registry_data:/var/lib/registry
                - registry_auth:/auth
              networks:
                - registry_network

          configs:
            nginx_infra_config:
              file: ./nginx-infra.conf

          volumes:
            registry_data:
            registry_auth:

          networks:
            registry_network:
              driver: overlay
          EOF

            # Remove existing stack to avoid config conflicts
            docker stack rm teamhub 2>/dev/null || true
            echo "Waiting for stack removal to complete..."
            sleep 30

            # Clean up old configs
            docker config rm teamhub_nginx_infra_config 2>/dev/null || true

            # Deploy infrastructure services only
            echo "Deploying infrastructure services (nginx + registry)..."
            export PG_PASSWORD="${{ secrets.PG_PASSWORD }}"
            docker stack deploy -c docker-stack-infra.yml teamhub

            echo "Waiting for infrastructure services to be ready..."
            sleep 30

            # Wait for registry to be accessible through nginx
            for i in {1..15}; do
              if curl -f --connect-timeout 5 --max-time 10 -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/ >/dev/null 2>&1; then
                echo "âœ… Registry is accessible through nginx"
                break
              fi
              echo "Waiting for registry to be ready... (attempt $i/15)"
              sleep 10
            done

            # Final check
            if ! curl -f --connect-timeout 5 --max-time 10 -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/ >/dev/null 2>&1; then
              echo "âŒ Registry is still not accessible after 2.5 minutes"
              echo "Checking service status:"
              docker service ls
              echo "Registry logs:"
              docker service logs teamhub_registry --tail 20
              echo "Nginx logs:"
              docker service logs teamhub_nginx --tail 20
              exit 1
            fi
          else
            echo "âœ… Infrastructure already exists, skipping infrastructure deployment"
          fi

      - name: Ensure Pinggy tunnel is running
        run: |
          # Single tunnel with wildcard domain forwarding
          if ! docker ps --filter "name=pinggy-tunnel" --filter "status=running" --format "{{.Names}}" | grep -q "^pinggy-tunnel$"; then
            echo "Wildcard tunnel not running, setting it up..."
            docker stop pinggy-tunnel 2>/dev/null || true
            docker rm pinggy-tunnel 2>/dev/null || true
            # Single tunnel through nginx reverse proxy
            # All services accessible through port 80 with path-based routing
            docker run --net=host --name=pinggy-tunnel -d pinggy/pinggy \
              -p 443 \
              -R0:127.0.0.1:80 \
              -o StrictHostKeyChecking=no -o ServerAliveInterval=30 \
              FpyP2PGUXy0@pro.pinggy.io
            echo "Waiting for wildcard tunnel to be ready..."
            sleep 15

            # Show tunnel information
            echo "Tunnel logs:"
            docker logs pinggy-tunnel 2>/dev/null | tail -20 || echo "No logs available yet"

            echo "Waiting additional time for all ports to be mapped..."
            sleep 10
            echo "Final tunnel status:"
            docker logs pinggy-tunnel 2>/dev/null | tail -30 || echo "No logs available yet"
          else
            echo "Wildcard Pinggy tunnel is already running."
          fi

          # Clean up any orphaned pinggy containers (containers without proper names)
          echo "Cleaning up orphaned pinggy containers..."
          docker ps -a --filter "ancestor=pinggy/pinggy" --format "{{.Names}}" | grep -v -E "^pinggy-tunnel$" | xargs -r docker rm -f

      - name: Test external registry access after tunnel setup
        run: |
          echo "Testing external registry access via Pinggy tunnel..."

          # Wait a bit more for tunnel to stabilize
          sleep 10

          # Test with HTTPS (since Pinggy exposes port 443)
          if curl -f --connect-timeout 10 --max-time 30 -u docker:k8mX9pL2nQ7vR4wE https://r1.teamxagents.com/v2/ >/dev/null 2>&1; then
            echo "âœ… Registry accessible via HTTPS through tunnel"
          else
            echo "âš ï¸ Registry not accessible via HTTPS, checking tunnel status..."
            docker logs pinggy-tunnel --tail 10
            echo "Checking local registry status..."
            curl -f -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/ || echo "Local registry also not accessible"
          fi

      - name: Export tunnel readiness status
        id: tunnel_status
        run: |
          # Test if tunnel is working and export status
          if curl -f --connect-timeout 5 --max-time 10 -u docker:k8mX9pL2nQ7vR4wE https://r1.teamxagents.com/v2/ >/dev/null 2>&1; then
            echo "tunnel_ready=true" >> $GITHUB_OUTPUT
            echo "âœ… Tunnel is ready for external access"
          else
            echo "tunnel_ready=false" >> $GITHUB_OUTPUT
            echo "âŒ Tunnel is not ready - build-and-push may fail"
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: [prepare-tag, setup-registry]
    outputs:
      tag: ${{ needs.prepare-tag.outputs.tag }}
    env:
      # Registry accessible from GitHub via nginx reverse proxy
      # Docker registry accessible via /v2/ path on the main domain
      REGISTRY_DOMAIN: 'r1.teamxagents.com'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/teamhub/Dockerfile
          push: false
          tags: |
            teamhub:latest
            teamhub:${{ needs.prepare-tag.outputs.tag }}
          outputs: type=docker,dest=/tmp/teamhub.tar

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: teamhub-image
          path: /tmp/teamhub.tar
          retention-days: 1

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Test DNS and connectivity before login
        run: |
          echo "Testing DNS resolution for $REGISTRY_DOMAIN..."

          # Test DNS resolution
          if nslookup $REGISTRY_DOMAIN; then
            echo "âœ… DNS resolution successful"
          else
            echo "âŒ DNS resolution failed"
            exit 1
          fi

          # Test basic connectivity (HTTPS since Pinggy exposes port 443)
          echo "Testing basic connectivity to $REGISTRY_DOMAIN..."
          if curl -I --connect-timeout 10 --max-time 30 https://$REGISTRY_DOMAIN 2>/dev/null; then
            echo "âœ… HTTPS connection successful"
          else
            echo "âš ï¸ HTTPS connection failed, trying HTTP as fallback..."
            if curl -I --connect-timeout 10 --max-time 30 http://$REGISTRY_DOMAIN 2>/dev/null; then
              echo "âœ… HTTP connection successful (unexpected but working)"
            else
              echo "âŒ Both HTTPS and HTTP connections failed"
            fi
          fi

          # Test registry endpoint specifically (HTTPS first)
          echo "Testing registry endpoint /v2/..."
          if curl -I --connect-timeout 10 --max-time 30 https://$REGISTRY_DOMAIN/v2/ 2>/dev/null; then
            echo "âœ… Registry endpoint accessible via HTTPS"
          else
            echo "âš ï¸ Registry endpoint not accessible via HTTPS, trying HTTP..."
            if curl -I --connect-timeout 10 --max-time 30 http://$REGISTRY_DOMAIN/v2/ 2>/dev/null; then
              echo "âœ… Registry endpoint accessible via HTTP (unexpected but working)"
            else
              echo "âŒ Registry endpoint not accessible"
            fi
          fi

      - name: Login to external registry via Pinggy
        run: |
          echo "Logging in to registry at https://$REGISTRY_DOMAIN (Pinggy exposes HTTPS)"
          echo "k8mX9pL2nQ7vR4wE" | docker login https://$REGISTRY_DOMAIN -u docker --password-stdin

      - name: Load and push image to external registry
        run: |
          # Load the built image
          docker load -i /tmp/teamhub.tar

          # Tag for external registry
          docker tag teamhub:${{ needs.prepare-tag.outputs.tag }} $REGISTRY_DOMAIN/teamhub:${{ needs.prepare-tag.outputs.tag }}
          docker tag teamhub:latest $REGISTRY_DOMAIN/teamhub:latest

          # Push to external registry with retry logic
          for i in {1..3}; do
            echo "Pushing images to external registry (attempt $i/3)..."
            if docker push $REGISTRY_DOMAIN/teamhub:${{ needs.prepare-tag.outputs.tag }} && docker push $REGISTRY_DOMAIN/teamhub:latest; then
              echo "Successfully pushed images to external registry"
              break
            else
              echo "Push failed, retrying in 10 seconds..."
              sleep 10
              if [ $i -eq 3 ]; then
                echo "Failed to push after 3 attempts"
                exit 1
              fi
            fi
          done

  deploy:
    runs-on: self-hosted
    needs: build-and-push
    steps:
      - name: Checkout required files
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-stack.yml
            nginx.conf
          sparse-checkout-cone-mode: false

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: teamhub-image
          path: /tmp

      - name: Load Docker image
        run: docker load -i /tmp/teamhub.tar

      - name: Login to local registry
        run: |
          echo "Logging in to local registry at localhost:5000"
          echo "k8mX9pL2nQ7vR4wE" | docker login localhost:5000 -u docker --password-stdin

      - name: Tag and push to local registry
        run: |
          docker tag teamhub:${{ needs.build-and-push.outputs.tag }} localhost:5000/teamhub:${{ needs.build-and-push.outputs.tag }}
          docker tag teamhub:latest localhost:5000/teamhub:latest

          # Push with retry logic
          for i in {1..3}; do
            echo "Pushing images to registry (attempt $i/3)..."
            if docker push localhost:5000/teamhub:${{ needs.build-and-push.outputs.tag }} && docker push localhost:5000/teamhub:latest; then
              echo "Successfully pushed images to registry"
              break
            else
              echo "Push failed, retrying in 10 seconds..."
              sleep 10
              if [ $i -eq 3 ]; then
                echo "Failed to push after 3 attempts"
                exit 1
              fi
            fi
          done

      - name: Update docker-stack.yml with new image tag
        run: |
          sed -i "s|localhost:5000/teamhub:.*|localhost:5000/teamhub:${{ needs.build-and-push.outputs.tag }}|" docker-stack.yml

      - name: Deploy full application stack
        run: |
          echo "Deploying full application stack (including teamhub)..."
          export PG_PASSWORD="${{ secrets.PG_PASSWORD }}"

          # Check if we're transitioning from infrastructure-only to full stack
          USING_INFRA_CONFIG=false
          if docker config ls --filter name=teamhub_nginx_infra_config --format "{{.Name}}" | grep -q teamhub_nginx_infra_config; then
            echo "ðŸ”„ Transitioning from infrastructure-only to full stack deployment"
            USING_INFRA_CONFIG=true
          fi

                    # Use existing nginx.conf file for full configuration

          if [ "$USING_INFRA_CONFIG" = true ]; then
            # First deployment: transition from infrastructure to full stack
            echo "ðŸš€ First deployment: Transitioning to full stack with nginx.conf"

            # Update the docker-stack.yml to use file-based config instead of external
            sed -i 's/external: true/file: .\/nginx.conf/' docker-stack.yml
            sed -i 's/name: teamhub_nginx_config_v4//' docker-stack.yml

            # Deploy the full stack (nginx.conf is already checked out)
            docker stack deploy -c docker-stack.yml teamhub

            # Clean up the temporary infrastructure config after successful deployment
            echo "ðŸ§¹ Cleaning up temporary infrastructure config"
            sleep 30  # Wait for deployment to complete
            docker config rm teamhub_nginx_infra_config 2>/dev/null || true

          else
            # Subsequent deployments: just update the stack
            echo "ðŸ”„ Updating existing full stack deployment"
            docker stack deploy -c docker-stack.yml teamhub
          fi

          echo "Waiting for teamhub service to be ready..."
          sleep 30

      - name: Prune stopped containers
        run: docker container prune -f
