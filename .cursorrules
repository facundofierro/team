# TeamHub Cursor Rules

## Project Overview

TeamHub is an enterprise AI agent management platform built with Next.js 14, TypeScript, and a modern monorepo structure. It provides multi-tenant environments for organizations to create, manage, and orchestrate AI agents at scale.

## Architecture Guidelines

### Monorepo Structure

- Use `pnpm` for package management across the monorepo
- Follow the established folder structure: `apps/`, `packages/`, `infrastructure/`, `docs/`
- Each package should have clear responsibilities and minimal dependencies
- Use Turbo for build orchestration and caching

### Applications

- **teamhub**: Main Next.js application (UI + API)
- **ai-gateway**: AI provider abstraction service
- **browser-service**: Automated browser control (currently disabled due to Playwright build issues)

### Packages

- **teamhub-ai**: AI functions, tools, and agent communication
- **teamhub-db**: Database schemas, ORM functions, and data access
- **ai-services**: Multi-provider AI service abstractions
- **drizzle-reactive**: Reactive database library for zero-config real-time features

## Technology Stack Conventions

### Frontend (Next.js 14)

- Use App Router exclusively (no Pages Router)
- Prefer Server Components when possible, use Client Components only when necessary
- Always mark Client Components with `'use client'` directive
- Use TypeScript strictly - no `any` types without justification
- Follow shadcn/ui component patterns and naming conventions

### UI/UX Standards

- Use shadcn/ui components exclusively for consistency
- Follow the established color scheme: `bg-menu`, `bg-menu2`, `bg-background`, etc.
- Implement responsive design with mobile-first approach
- Use Tailwind CSS classes consistently
- Maintain accessibility standards (ARIA labels, keyboard navigation)

### Component Organization & UX-Core Package

TeamHub uses a centralized component system through the `packages/ux-core` package to ensure consistent styling and maintainability across the entire monorepo.

#### Package Structure

```
packages/ux-core/src/
├── components/          # External component libraries (NOT exported)
│   ├── shadcn/         # shadcn/ui components
│   ├── tailark/        # Tailark components
│   ├── origin/         # Origin UI components
│   ├── motion/         # Framer Motion components
│   ├── ai-sdk/         # AI SDK components
│   └── aceternity/     # Aceternity UI components
├── components-core/     # TeamHub application components (exported)
│   ├── teamhub-button.tsx
│   ├── teamhub-form.tsx
│   ├── teamhub-input.tsx
│   ├── teamhub-dialog.tsx
│   └── teamhub-card.tsx
├── components-site/     # Landing page & public site components (exported)
│   ├── features/        # Feature showcase components
│   ├── layout/          # Layout components
│   ├── hero/            # Hero section components
│   ├── content/         # Content display components
│   ├── ai-widget/       # AI widget components
│   └── navigation/      # Navigation components
├── styles/              # Global styles and design tokens
├── types/               # TypeScript type definitions
└── utils/               # Utility functions
```

#### Component Usage Guidelines

**1. External Components (`components/`)**

- **NOT exported** - these are internal dependencies only
- Used as base components for building custom TeamHub components
- All styling and customization should be applied in `components-core` or `components-site`
- Never import directly from external packages in applications

**2. Core Components (`components-core/`)**

- **Exported** for use in TeamHub applications (`apps/teamhub`, `apps/ai-gateway`)
- Contain all styling, colors, and TeamHub-specific design tokens
- Built on top of external components with consistent theming
- Use TeamHub color scheme: `bg-menu`, `bg-menu2`, `bg-background`, etc.
- Include responsive design and accessibility features

**3. Site Components (`components-site/`)**

- **Exported** for use in public-facing sites (`apps/landing-page`)
- Optimized for marketing and public presentation
- May include different styling than core components
- Focus on conversion and user engagement

#### Import Patterns

```typescript
// ✅ CORRECT: Import from ux-core package
import { Button, Card, TeamHubButton } from '@teamhub/ux-core'

// ❌ WRONG: Direct import from external packages
import { Button } from '@/components/ui/button'
import { Button } from 'shadcn/ui'

// ✅ CORRECT: Use TeamHub-styled components
<TeamHubButton variant="primary" size="lg">
  Create Agent
</TeamHubButton>

// ❌ WRONG: Use raw external components
<Button variant="default">Create Agent</Button>
```

#### Styling & Theming

- **All styling changes must be made in `packages/ux-core`**
- Use Tailwind CSS classes consistently across all components
- Define design tokens in `packages/ux-core/src/styles/`
- Maintain consistent spacing, typography, and color schemes
- Implement responsive breakpoints consistently

#### Component Development Workflow

1. **Base Component**: Start with external component (shadcn, etc.)
2. **Styling**: Apply TeamHub design system in `components-core/`
3. **Export**: Add to `packages/ux-core/src/index.ts`
4. **Usage**: Import from `@teamhub/ux-core` in applications
5. **Updates**: Modify styling only in ux-core package

#### Benefits of This Approach

- **Single Source of Truth**: All styling changes in one place
- **Consistency**: Uniform appearance across all applications
- **Maintainability**: Easy to update design system globally
- **Performance**: Optimized bundle sizes with tree-shaking
- **Developer Experience**: Clear import patterns and component hierarchy

### State Management

- Use Zustand for client-side state management
- Keep stores focused and minimal (agentStore, organizationStore, navigationStore)
- Avoid prop drilling - use stores for shared state
- Server state should be managed separately from client state

### Database & ORM

- Use Drizzle ORM exclusively for database operations
- **NEW: Use @drizzle/reactive for all database functions**
- All database functions should be in `packages/teamhub-db`
- Follow type-safe query patterns
- Use transactions for multi-table operations
- Implement proper error handling and validation

### AI Integration

- All AI provider interactions should go through `packages/ai-services`
- Support multiple providers: OpenAI, DeepSeek, Fal, Eden AI
- Implement streaming responses where possible
- Handle region restrictions gracefully (especially for OpenAI embeddings)
- Use the established tool framework for new integrations

## @drizzle/reactive Integration Guidelines

### Client/Server imports

- Server-only code must import from `@drizzle/reactive/server`.
- Client-only code must import from `@drizzle/reactive/client`.
- Do not mix client modules on the server or vice versa.

### App provider usage (global)

- Provide reactive context once at the app root using `TrpcReactiveProvider`.
- Inputs:
  - `organizationId` (URL/store/session)
  - `relations` from `@teamhub/db/reactive-config` (client-safe)
  - `trpcClient` via `createTRPCProxyClient` + `httpBatchLink('/api/trpc')`
- Do not add per-page providers.

### Core Reactive Patterns

Always use `defineReactiveFunction` for database operations:

```typescript
// ✅ CORRECT: Reactive function with explicit name
export const getAgents = defineReactiveFunction({
  name: 'agents.getAll', // Used for cache keys AND tRPC procedures
  input: z.object({
    organizationId: z.string(),
    limit: z.number().optional().default(50),
  }),
  dependencies: ['agent'], // Tables this function reads from
  handler: async (input, db) => {
    return db.agents.findMany({
      where: { organizationId: input.organizationId },
      limit: input.limit,
    })
  },
})

// ✅ CORRECT: Server-side execution
const agents = await getAgents.execute({ organizationId: 'org-123' }, db)

// ✅ CORRECT: tRPC integration
const router = createReactiveRouter({ db }).addQuery(getAgents) // Creates 'agents.getAll' procedure automatically

// ✅ CORRECT: Client usage
const { data: agents, isStale } = useReactive('agents.getAll', {
  organizationId,
})
```

### TeamHub Relations Configuration

```typescript
const teamhubReactiveConfig = {
  relations: {
    // When agent changes, invalidate these queries
    agent: ['message.fromAgentId', 'memory.agentId', 'organization.id'],

    // When organization changes, invalidate these queries
    organization: ['agent.organizationId', 'tool.organizationId'],

    // When message changes, invalidate these queries
    message: ['agent.fromAgentId', 'agent.toAgentId'],

    // When memory changes, invalidate these queries
    memory: ['agent.agentId'],

    // When tool changes, invalidate these queries
    tool: ['organization.id'],
  },
}
```

### Migration from Legacy Patterns

```typescript
// ❌ OLD: Manual tRPC procedures
export const agentsRouter = t.router({
  getAll: t.procedure
    .input(z.object({ organizationId: z.string() }))
    .query(async ({ input }) => {
      return db.agents.findMany({ where: input })
    }),
})

// ✅ NEW: Reactive function + auto-generated tRPC
export const getAgents = defineReactiveFunction({
  name: 'agents.getAll',
  input: z.object({ organizationId: z.string() }),
  dependencies: ['agent'],
  handler: async (input, db) => {
    return db.agents.findMany({ where: input })
  },
})

const router = createReactiveRouter({ db }).addQuery(getAgents)
```

### Multi-tenant DB rules (TeamHub specific)

- Resolve tenant DB via main DB: look up `organization.databaseName` by `organizationId`.
- Never use `organizationId` as a database name.
- Read paths must not create databases. If DB missing (3D000), either:
  - propagate the error so client keeps cache intact, or
  - return empty for read-only endpoints by product decision (avoid caching as fresh).
- Provisioning (create DB/schemas) belongs in explicit setup flows, not reactive handlers.

### LocalStorage caching (client)

- Storage is sharded per query:
  - Index per-org key: `reactive_registry_<orgId>` stores only metadata.
  - Per-query entry key: `@drizzle/reactive:entry:<orgId>:<hash>` stores `{ name, input, queryKey, data }`.
- Do not write cache on errors.

### UI layout when adding tabs with scroll

- Parent flex containers must include `min-h-0`.
- Tabs wrapper: `className="flex h-full flex-col min-h-0"`.
- TabsContent: `className="flex-1 min-h-0 overflow-hidden p-0"`.
- Inner ScrollArea: `className="flex-1 min-h-0 ..."`.

## Code Style & Quality

### TypeScript

- Enable strict mode and all strict checks
- Use proper type definitions - avoid `any`
- Prefer interfaces over types for object shapes
- Use generic types for reusable components
- Export types alongside implementations

### File Organization

- Use kebab-case for file names
- Group related components in directories
- Index files should re-export main components
- Keep components focused and single-responsibility
- Use meaningful, descriptive names

### Naming Conventions

- Components: PascalCase (e.g., `AgentDetail`, `ChatCard`)
- Functions: camelCase (e.g., `sendChat`, `getAgents`)
- Reactive Functions: camelCase with hierarchical names (e.g., `agents.getAll`, `agents.memory.getRecent`)
- Constants: SCREAMING_SNAKE_CASE (e.g., `API_ENDPOINTS`)
- Files: kebab-case (e.g., `agent-detail.tsx`, `chat-card.tsx`)
- Database entities: camelCase in code, snake_case in database

### Error Handling

- Always handle errors gracefully
- Use try-catch blocks for async operations
- Provide meaningful error messages to users
- Log errors appropriately with context
- Implement proper fallbacks and loading states

## Component Guidelines

### React Components

- Use functional components exclusively
- Implement proper loading and error states
- Use React.memo() for expensive computations
- Prefer composition over inheritance
- Keep components under 200 lines when possible

### Component Development with UX-Core

- **Always use components from `@teamhub/ux-core` package**
- Never create new UI components directly in applications
- Extend existing ux-core components when new functionality is needed
- Follow the established component hierarchy: external → core → site
- Maintain consistent prop interfaces across similar components

### Component Styling

- **All styling must be defined in `packages/ux-core`**
- Use Tailwind CSS classes consistently
- Follow TeamHub design system: colors, spacing, typography
- Implement responsive design patterns
- Ensure accessibility compliance (ARIA labels, keyboard navigation)

### Props & Types

- Define explicit prop interfaces
- Use optional props with default values
- Implement prop validation with TypeScript
- Document complex props with JSDoc comments
- Avoid passing entire objects when specific props will do

### Hooks

- Use built-in hooks appropriately
- **NEW: Use `useReactive` instead of manual React Query**
- Create custom hooks for reusable logic
- Keep hooks focused and testable
- Follow hooks rules (always call at top level)
- Use dependency arrays correctly in useEffect

## API & Server Actions

### Server Actions

- **NEW: Use reactive functions for mutations**
- Implement proper validation using Zod
- Handle authentication and authorization
- Return typed responses
- Use revalidatePath/revalidateTag appropriately

### API Routes

- Use API routes for external integrations
- **NEW: Use reactive functions for internal data operations**
- Implement proper error handling and status codes
- Use middleware for authentication
- Document API endpoints
- Follow RESTful conventions where applicable

### Database Operations

- **NEW: All database operations should use defineReactiveFunction**
- Use organization-scoped queries for multi-tenancy
- Implement proper pagination for large datasets
- Use database transactions for consistency
- Handle unique constraints and conflicts
- Optimize queries for performance

## Security Guidelines

### Authentication & Authorization

- Use NextAuth.js for authentication
- Implement proper session management
- Check permissions on all protected routes
- Validate user access to organizations
- Use environment variables for secrets

### Data Protection

- Implement organization-level data isolation
- Validate all input data
- Sanitize user-generated content
- Use parameterized queries to prevent SQL injection
- Implement rate limiting where appropriate

### Environment Variables

- Use `.env.local` for development
- Never commit secrets to version control
- Use GitHub Secrets for production
- Validate required environment variables at startup
- Provide meaningful defaults where possible

## AI & Tools Development

### Tool Creation

- Implement the `ToolTypeDefinition` interface
- Use Zod schemas for parameter validation
- Include proper error handling and timeouts
- Test tools thoroughly before deployment
- Document tool capabilities and limitations

### AI Provider Integration

- Follow the established provider abstraction pattern
- Implement both generation and discovery functions
- Handle provider-specific errors gracefully
- Support streaming where available
- Test with multiple providers

### Memory Management

- **NEW: Use reactive functions for memory operations**
- Use semantic search with pgvector when possible
- Implement proper memory categorization
- Handle embedding generation failures gracefully
- Respect retention policies and cleanup old data
- Optimize memory retrieval performance

## Performance Guidelines

### Frontend Performance

- Use React.memo() for expensive components
- **NEW: Leverage reactive caching automatically**
- Implement proper loading states
- Optimize images and assets
- Use code splitting where appropriate
- Monitor bundle size

### Database Performance

- **NEW: Reactive functions provide automatic caching**
- Use indexes appropriately
- Implement query optimization
- Use connection pooling
- Monitor query performance
- Implement proper caching strategies

### Caching

- **NEW: @drizzle/reactive handles caching automatically**
- Use Redis for application caching when needed
- Implement proper cache invalidation via relations config
- Cache expensive computations
- Use browser caching for static assets
- Monitor cache hit rates

## Common TeamHub Patterns

### Agent Operations

```typescript
// Get agents with statistics
export const getAgentsWithStats = defineReactiveFunction({
  name: 'agents.getWithStats',
  input: z.object({ organizationId: z.string() }),
  dependencies: ['agent', 'message', 'memory'],
  handler: async (input, db) => {
    // Complex query with joins
  },
})

// Update agent
export const updateAgent = defineReactiveFunction({
  name: 'agents.update',
  input: z.object({ id: z.string(), data: agentUpdateSchema }),
  dependencies: ['agent'],
  handler: async (input, db) => {
    return db.agents.update({
      where: { id: input.id },
      data: input.data,
    })
  },
})
```

### Memory Operations

```typescript
export const getAgentMemories = defineReactiveFunction({
  name: 'agents.memory.getAll',
  input: z.object({ agentId: z.string(), limit: z.number().optional() }),
  dependencies: ['memory', 'agent'],
  handler: async (input, db) => {
    return db.memory.findMany({
      where: { agentId: input.agentId },
      limit: input.limit,
      orderBy: { createdAt: 'desc' },
    })
  },
})
```

### Organization Operations

```typescript
export const getOrganizationOverview = defineReactiveFunction({
  name: 'organizations.getOverview',
  input: z.object({ organizationId: z.string() }),
  dependencies: ['organization', 'agent', 'message', 'memory', 'tool'],
  handler: async (input, db) => {
    // Comprehensive overview query
  },
})
```

## Debugging & Troubleshooting

### Logging

- Use structured logging with context
- Include operation IDs for tracing
- Log errors with stack traces
- Use appropriate log levels
- Include timing information

### Development Tools

- Use React DevTools for component debugging
- Use Drizzle Studio for database inspection
- **NEW: Monitor reactive cache hits/misses in console**
- Use browser DevTools for performance profiling
- Use TypeScript strict mode for better error detection
- Use ESLint and Prettier for code quality

### Common Issues

- **NEW: Check reactive function dependencies if data seems stale**
- **NEW: Verify relations config covers all table relationships**
- Playwright build issues: Browser service currently disabled
- Database connection issues: Check environment variables
- Authentication issues: Verify ALLOWED_EMAILS configuration
- Memory issues: Monitor conversation memory growth

## Task Management System

### Task Organization

TeamHub uses a milestone-based task management system with priority-based organization:

- **Tasks are organized by priority**: A (Critical), B (High), C (Medium), D (Future)
- **File naming convention**: `{Priority}: {task-name} ({story-points})`
- **Story points scale**: 1 (1-2 days), 2 (3-5 days), 3 (1-2 weeks), 4 (2-3 weeks), 5 (3-4 weeks)
- **Directory structure**: `pending/`, `doing/`, `done/` based on task status

### Current Milestones

1. **Milestone 1 (Q1 2025)**: Internal Tool Foundation - Complete Priority A tasks
2. **Milestone 2 (Q2 2025)**: Public Agent Platform - Complete Priority B tasks
3. **Milestone 3 (Q3 2025)**: Advanced Analytics - Complete Priority C tasks

### Task Status Locations

- **Pending**: `specs/tasks/pending/` - Tasks waiting to be started
- **Doing**: `specs/tasks/doing/` - Tasks currently in development
- **Done**: `specs/tasks/done/` - Completed tasks with implementation details

### When Working on Tasks

1. **Check current priorities** in `specs/tasks/tasks.md`
2. **Move tasks between directories** as status changes
3. **Update task files** with progress, blockers, and completion details
4. **Follow priority order** - complete A tasks before B, B before C, etc.
5. **Estimate story points** accurately for new tasks
6. **Document learnings** in completed tasks for future reference

## AI Assistant Guidance

When helping with TeamHub development:

1. **Always suggest @drizzle/reactive patterns** for database operations
2. **Check existing relations config** when adding new reactive functions
3. **Suggest appropriate function names** following hierarchical conventions
4. **Analyze function dependencies** based on actual table usage
5. **Recommend cache invalidation strategies** based on data relationships
6. **Help migrate legacy patterns** to reactive functions
7. **Suggest performance optimizations** using reactive features
8. **Follow task priority system** - focus on current milestone tasks first
9. **Update task status** when completing work or encountering blockers
10. **Document implementation details** in task files for team knowledge

### Component Development Guidance

11. **Always use `@teamhub/ux-core` package** for UI components
12. **Check existing ux-core components** before suggesting new ones
13. **Follow component hierarchy**: external → core → site components
14. **Suggest styling changes in ux-core** package, not in applications
15. **Maintain consistent design system** across all components
16. **Use TeamHub color scheme** and design tokens consistently
17. **Implement responsive design** patterns in all components
18. **Ensure accessibility compliance** in component suggestions

## Landing Page Component Architecture

### Component Separation of Concerns

TeamHub follows a strict separation of concerns for landing page components to ensure maintainability, reusability, and clear responsibility boundaries.

#### Architecture Overview

```
apps/landing-page/          # Content & Logic Layer
├── src/
│   ├── content/           # All text content, copy, and messaging
│   ├── handlers/          # Event handlers and business logic
│   ├── stores/            # State management (Zustand)
│   └── app/               # Next.js app structure

packages/ux-core/src/components-site/  # Presentation Layer
├── navigation/            # Header, menu, language switcher
├── hero/                  # Hero sections and CTAs
├── features/              # Feature showcases and grids
├── content/               # Content sections (problem, solution, etc.)
├── ai-widget/             # AI chat widgets and interactions
├── layout/                # Layout components and containers
└── colors.ts              # Site-specific color definitions
```

#### Color System Rules

**CRITICAL: All colors MUST be defined in color files, never hardcoded**

1. **Site Colors** (`packages/ux-core/src/components-site/colors.ts`)

   - **ONLY** for landing page and public-facing sites
   - Contains `siteColors` and `siteUtils` exports
   - Based on reference design color palette
   - Includes gradients, backgrounds, text colors, and borders

2. **Core Colors** (`packages/ux-core/src/components-core/light-theme-colors.ts`)

   - **ONLY** for TeamHub application components
   - Contains `coreColors` and `coreUtils` exports
   - Used in buttons, forms, cards, and internal UI

3. **Dark Theme Colors** (`packages/ux-core/src/components-core/dark-theme-colors.ts`)
   - **ONLY** for dark-themed components (sidebar, navigation)
   - Contains `componentColors` and `componentUtils` exports

#### Component Development Rules

**1. Visual Components (UX-Core Package)**

```typescript
// ✅ CORRECT: Component in ux-core with no content
// packages/ux-core/src/components-site/hero/landing-hero.tsx
interface LandingHeroProps {
  title: string
  subtitle: string
  ctaText: string
  onCtaClick: () => void
  backgroundImage?: string
}

export const LandingHero = ({
  title,
  subtitle,
  ctaText,
  onCtaClick,
  backgroundImage,
}: LandingHeroProps) => {
  return (
    <section className={`${siteColors.gradients.primary} min-h-screen`}>
      <h1 className={siteColors.text.white}>{title}</h1>
      <p className={siteColors.text.gray300}>{subtitle}</p>
      <button
        className={siteUtils.getButtonClasses('primary')}
        onClick={onCtaClick}
      >
        {ctaText}
      </button>
    </section>
  )
}
```

**2. Content & Logic (Landing Page App)**

```typescript
// ✅ CORRECT: Content and handlers in landing page app
// apps/landing-page/src/content/hero-content.ts
export const heroContent = {
  title: 'Transform Your Business with AI Agents',
  subtitle:
    'Deploy intelligent agents that work 24/7 to automate your workflows',
  ctaText: 'Get Started Free',
}

// apps/landing-page/src/handlers/navigation-handlers.ts
export const navigationHandlers = {
  onCtaClick: () => {
    // Business logic for CTA click
    analytics.track('hero_cta_clicked')
    router.push('/signup')
  },
}

// apps/landing-page/src/app/page.tsx
import { LandingHero } from '@teamhub/ux-core'
import { heroContent } from '../content/hero-content'
import { navigationHandlers } from '../handlers/navigation-handlers'

export default function LandingPage() {
  return (
    <LandingHero
      title={heroContent.title}
      subtitle={heroContent.subtitle}
      ctaText={heroContent.ctaText}
      onCtaClick={navigationHandlers.onCtaClick}
    />
  )
}
```

#### Strict Rules for Component Development

**❌ NEVER DO:**

1. **Hardcode colors in components**

```typescript
// ❌ WRONG: Hardcoded colors
<div className="bg-[#f45584] text-white">
```

2. **Include content/text in ux-core components**

```typescript
// ❌ WRONG: Content in component
export const LandingHero = () => {
  return (
    <section>
      <h1>Transform Your Business with AI Agents</h1> {/* NO! */}
    </section>
  )
}
```

3. **Include business logic in ux-core components**

```typescript
// ❌ WRONG: Business logic in component
export const LandingHero = ({ onCtaClick }: Props) => {
  const handleClick = () => {
    analytics.track('cta_clicked') // NO! This belongs in handlers
    router.push('/signup') // NO! This belongs in handlers
  }
}
```

4. **Use different color systems in wrong contexts**

```typescript
// ❌ WRONG: Using site colors in core components
import { siteColors } from '@teamhub/ux-core'
// This should use coreColors instead

// ❌ WRONG: Using core colors in site components
import { coreColors } from '@teamhub/ux-core'
// This should use siteColors instead
```

**✅ ALWAYS DO:**

1. **Use defined color systems**

```typescript
// ✅ CORRECT: Using site colors for landing page
import { siteColors, siteUtils } from '@teamhub/ux-core'

<div className={siteColors.gradients.primary}>
<button className={siteUtils.getButtonClasses('primary')}>
```

2. **Pass content as props**

```typescript
// ✅ CORRECT: Content passed as props
<LandingHero
  title="Transform Your Business"
  subtitle="Deploy intelligent agents"
  ctaText="Get Started Free"
/>
```

3. **Pass handlers as props**

```typescript
// ✅ CORRECT: Handlers passed as props
<LandingHero
  onCtaClick={navigationHandlers.onCtaClick}
  onScroll={interactionHandlers.onScroll}
/>
```

4. **Keep components pure and reusable**

```typescript
// ✅ CORRECT: Pure component with clear interface
interface LandingHeroProps {
  title: string
  subtitle: string
  ctaText: string
  onCtaClick: () => void
  className?: string
}
```

#### File Organization Rules

**UX-Core Components (`packages/ux-core/src/components-site/`)**

- **NO content files** - only component definitions
- **NO handler files** - only component logic
- **NO business logic** - only presentation logic
- **ALL styling** - colors, layouts, animations
- **ALL responsive design** - mobile-first approach

**Landing Page App (`apps/landing-page/src/`)**

- **ALL content files** - text, copy, messaging
- **ALL handler files** - event handlers, business logic
- **ALL state management** - Zustand stores
- **NO styling** - only imports from ux-core
- **NO component definitions** - only component usage

#### Import Patterns

```typescript
// ✅ CORRECT: Landing page imports
import {
  LandingHero,
  LandingFeatures,
  LandingHeader,
  siteColors,
  siteUtils,
} from '@teamhub/ux-core'

// ✅ CORRECT: Content imports
import { heroContent } from '../content/hero-content'
import { featuresContent } from '../content/features-content'

// ✅ CORRECT: Handler imports
import { navigationHandlers } from '../handlers/navigation-handlers'
import { formHandlers } from '../handlers/form-handlers'
```

#### Testing & Validation

**Component Testing Checklist:**

1. **Colors**: All colors come from defined color systems
2. **Content**: No hardcoded text in components
3. **Logic**: No business logic in components
4. **Props**: All content and handlers passed as props
5. **Reusability**: Components work with different content
6. **Responsive**: Mobile-first responsive design
7. **Accessibility**: ARIA labels and keyboard navigation

**Content Testing Checklist:**

1. **Separation**: Content files contain only text/copy
2. **Handlers**: Handler files contain only business logic
3. **Imports**: Landing page only imports from ux-core
4. **Props**: All content passed to components as props
5. **State**: State management in dedicated store files

#### Benefits of This Architecture

1. **Maintainability**: Clear separation of concerns
2. **Reusability**: Components can be used with different content
3. **Consistency**: Unified color system and styling
4. **Scalability**: Easy to add new landing pages
5. **Testing**: Components and content can be tested separately
6. **Performance**: Optimized bundle sizes with tree-shaking
7. **Developer Experience**: Clear file organization and import patterns

Remember: Agelum is an enterprise platform - prioritize security, performance, maintainability, **reactive real-time features**, and **milestone-driven development** in all decisions.
