name: Deploy to Self-Hosted Server

on:
  push:
    branches:
      - main

jobs:
  prepare-tag:
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.set_tag.outputs.tag }}
    steps:
      - name: Set commit SHA as output
        id: set_tag
        run: echo "tag=${GITHUB_SHA}" >> $GITHUB_OUTPUT

  setup-registry:
    runs-on: self-hosted
    needs: prepare-tag
    steps:
      - name: Checkout only required files
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-stack.yml
            setup-registry.sh
            nginx-infra.conf
                              sparse-checkout-cone-mode: false

      - name: Install Pinggy CLI and setup SSH key
        run: |
          # Install Pinggy CLI from the correct URL
          if ! command -v pinggy &> /dev/null; then
            echo "Installing Pinggy CLI..."
            curl -sSL -o pinggy https://s3.ap-south-1.amazonaws.com/public.pinggy.binaries/cli/v0.2.2/linux/amd64/pinggy
            chmod +x pinggy
            sudo mv pinggy /usr/local/bin/
          fi

          # Generate SSH key for passwordless authentication and better stability
          if [ ! -f ~/.ssh/pinggy_key ]; then
            echo "Generating SSH key for stable tunnel connections..."
            ssh-keygen -t rsa -b 2048 -f ~/.ssh/pinggy_key -N ""
            chmod 600 ~/.ssh/pinggy_key
          fi

      - name: Setup Pinggy tunnel with improved process management
        run: |
          # Stop any conflicting services first
          echo "Stopping conflicting services..."
          snap stop nextcloud 2>/dev/null || true
          snap disable nextcloud 2>/dev/null || true

          # Kill any existing pinggy processes
          pkill -f pinggy 2>/dev/null || true
          sleep 2

          # Create a wrapper script for better process management
          echo "Creating Pinggy wrapper script..."
          cat > /tmp/start-pinggy.sh <<'EOF'
          #!/bin/bash

          # Function to cleanup on exit
          cleanup() {
            echo "Cleaning up Pinggy process..."
            pkill -f "pinggy.*FpyP2PGUXy0" 2>/dev/null || true
            exit 0
          }

          # Set up signal handlers
          trap cleanup SIGTERM SIGINT

          # Start Pinggy with restart logic
          while true; do
            echo "$(date): Starting Pinggy tunnel..."
            /usr/local/bin/pinggy --token FpyP2PGUXy0 -l 80 --notui 2>&1 | tee -a /tmp/pinggy.log

            # If we get here, pinggy exited
            echo "$(date): Pinggy exited, restarting in 10 seconds..."
            sleep 10
          done
          EOF

          chmod +x /tmp/start-pinggy.sh

          # Start the wrapper script in background with nohup
          echo "Starting Pinggy tunnel with auto-restart..."
          nohup /tmp/start-pinggy.sh > /tmp/pinggy-wrapper.log 2>&1 &
          PINGGY_PID=$!
          echo $PINGGY_PID > /tmp/pinggy.pid

          # Wait for tunnel to establish
          echo "Waiting for tunnel to establish connection..."
          sleep 20

          # Check if process is still running
          if kill -0 $PINGGY_PID 2>/dev/null; then
            echo "âœ… Pinggy wrapper process is running (PID: $PINGGY_PID)"
          else
            echo "âŒ Pinggy wrapper process failed to start"
            cat /tmp/pinggy-wrapper.log
            exit 1
          fi

          # Show tunnel information
          echo "Recent Pinggy logs:"
          tail -20 /tmp/pinggy.log 2>/dev/null || echo "No logs available yet"

      - name: Deploy infrastructure services (nginx + registry)
        run: |
          # Check if teamhub image already exists in registry
          echo "Checking if teamhub image exists in registry..."
          TEAMHUB_EXISTS=false
          if curl -f -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/teamhub/tags/list 2>/dev/null | grep -q "latest"; then
            echo "âœ… Teamhub image already exists in registry"
            TEAMHUB_EXISTS=true
          else
            echo "â„¹ï¸ Teamhub image not found in registry - first deployment"
          fi

          # Check if full stack is already deployed
          FULL_STACK_EXISTS=false
          if docker service ls --filter name=teamhub_teamhub --format "{{.Name}}" | grep -q teamhub_teamhub; then
            echo "âœ… Full stack already deployed"
            FULL_STACK_EXISTS=true
          fi

          # Only deploy infrastructure if teamhub image doesn't exist and full stack isn't deployed
          if [ "$TEAMHUB_EXISTS" = false ] && [ "$FULL_STACK_EXISTS" = false ]; then
            echo "ðŸš€ Deploying infrastructure services (nginx + registry) for first time..."

            # Ensure port 80 is available for Docker nginx
            echo "Ensuring port 80 is available..."
            netstat -tlnp | grep :80 || echo "Port 80 is free"

            # Check if registry volumes exist
            if ! docker volume ls --filter name=registry_data --format "{{.Name}}" | grep -q registry_data; then
              echo "Registry volumes not found. Running setup script..."
              chmod +x setup-registry.sh
              ./setup-registry.sh
            fi

            # Use existing nginx-infra.conf file (no need to create it)

            # Create a temporary stack file with only infrastructure services
            cat > docker-stack-infra.yml << 'EOF'
          version: '3.8'
          services:
            nginx:
              image: nginx:alpine
              deploy:
                replicas: 1
              ports:
                - '80:80'
                - '443:443'
              configs:
                - source: nginx_infra_config
                  target: /etc/nginx/nginx.conf
              networks:
                - registry_network

            registry:
              image: registry:2
              deploy:
                replicas: 1
                placement:
                  constraints:
                    - node.role == manager
              expose:
                - "5000"
              environment:
                - REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/var/lib/registry
                - REGISTRY_AUTH=htpasswd
                - REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm
                - REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd
              volumes:
                - registry_data:/var/lib/registry
                - registry_auth:/auth
              networks:
                - registry_network

          configs:
            nginx_infra_config:
              file: ./nginx-infra.conf

          volumes:
            registry_data:
            registry_auth:

          networks:
            registry_network:
              driver: overlay
          EOF

            # Remove existing stack to avoid config conflicts
            docker stack rm teamhub 2>/dev/null || true
            echo "Waiting for stack removal to complete..."
            sleep 30

            # Clean up old configs
            docker config rm teamhub_nginx_infra_config 2>/dev/null || true

            # Deploy infrastructure services only
            echo "Deploying infrastructure services (nginx + registry)..."
            export PG_PASSWORD="${{ secrets.PG_PASSWORD }}"
            docker stack deploy -c docker-stack-infra.yml teamhub

            echo "Waiting for infrastructure services to be ready..."
            sleep 30

            # Wait for registry to be accessible through nginx
            for i in {1..15}; do
              if curl -f --connect-timeout 5 --max-time 10 -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/ >/dev/null 2>&1; then
                echo "âœ… Registry is accessible through nginx"
                break
              fi
              echo "Waiting for registry to be ready... (attempt $i/15)"
              sleep 10
            done

            # Final check
            if ! curl -f --connect-timeout 5 --max-time 10 -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/ >/dev/null 2>&1; then
              echo "âŒ Registry is still not accessible after 2.5 minutes"
              echo "Checking service status:"
              docker service ls
              echo "Registry logs:"
              docker service logs teamhub_registry --tail 20
              echo "Nginx logs:"
              docker service logs teamhub_nginx --tail 20
              exit 1
            fi
          else
            echo "âœ… Infrastructure already exists, skipping infrastructure deployment"
          fi

      - name: Ensure Pinggy tunnel process is running
        run: |
          # Check if Pinggy wrapper process is running
          if [ -f /tmp/pinggy.pid ] && kill -0 $(cat /tmp/pinggy.pid) 2>/dev/null; then
            echo "âœ… Pinggy tunnel wrapper is already running (PID: $(cat /tmp/pinggy.pid))"
          else
            echo "ðŸ”„ Pinggy wrapper not running, restarting..."
            # Kill any existing processes
            pkill -f pinggy 2>/dev/null || true
            sleep 2

            # Restart the wrapper
            nohup /tmp/start-pinggy.sh > /tmp/pinggy-wrapper.log 2>&1 &
            PINGGY_PID=$!
            echo $PINGGY_PID > /tmp/pinggy.pid
            sleep 10

            if kill -0 $PINGGY_PID 2>/dev/null; then
              echo "âœ… Pinggy wrapper restarted successfully (PID: $PINGGY_PID)"
            else
              echo "âŒ Failed to restart Pinggy wrapper"
              cat /tmp/pinggy-wrapper.log
              exit 1
            fi
          fi

          # Show recent logs
          echo "Recent Pinggy logs:"
          tail -10 /tmp/pinggy.log 2>/dev/null || echo "No logs available yet"

      - name: Monitor tunnel stability
        run: |
          echo "Monitoring tunnel stability for 30 seconds..."
          for i in {1..6}; do
            if [ -f /tmp/pinggy.pid ] && kill -0 $(cat /tmp/pinggy.pid) 2>/dev/null; then
              echo "âœ… Tunnel wrapper still running (check $i/6, PID: $(cat /tmp/pinggy.pid))"
            else
              echo "âŒ Tunnel wrapper has failed! Checking logs..."
              echo "Wrapper logs:"
              tail -20 /tmp/pinggy-wrapper.log 2>/dev/null || echo "No wrapper logs available"
              echo "Pinggy logs:"
              tail -20 /tmp/pinggy.log 2>/dev/null || echo "No pinggy logs available"
              exit 1
            fi
            sleep 5
          done

      - name: Test external registry access after tunnel setup
        run: |
          echo "Testing external registry access via Pinggy tunnel..."

          # Wait a bit more for tunnel to stabilize
          sleep 10

          # Test with HTTPS (since Pinggy exposes port 443)
          if curl -f --connect-timeout 10 --max-time 30 -u docker:k8mX9pL2nQ7vR4wE https://r1.teamxagents.com/v2/ >/dev/null 2>&1; then
            echo "âœ… Registry accessible via HTTPS through tunnel"
          else
            echo "âš ï¸ Registry not accessible via HTTPS, checking tunnel status..."
            if [ -f /tmp/pinggy.pid ] && kill -0 $(cat /tmp/pinggy.pid) 2>/dev/null; then
              echo "Tunnel wrapper is running (PID: $(cat /tmp/pinggy.pid))"
            else
              echo "Tunnel wrapper is not running!"
            fi
            echo "Recent tunnel logs:"
            tail -10 /tmp/pinggy.log 2>/dev/null || echo "No tunnel logs available"
            echo "Checking local registry status..."
            curl -f -u docker:k8mX9pL2nQ7vR4wE http://127.0.0.1:80/v2/ || echo "Local registry also not accessible"
          fi

      - name: Export tunnel readiness status
        id: tunnel_status
        run: |
          # Check wrapper process status first
          if ! [ -f /tmp/pinggy.pid ] || ! kill -0 $(cat /tmp/pinggy.pid) 2>/dev/null; then
            echo "âŒ Pinggy wrapper is not running"
            echo "Wrapper logs:"
            tail -10 /tmp/pinggy-wrapper.log 2>/dev/null || echo "No wrapper logs available"
            echo "tunnel_ready=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Test if tunnel is working and export status
          if curl -f --connect-timeout 5 --max-time 10 -u docker:k8mX9pL2nQ7vR4wE https://r1.teamxagents.com/v2/ >/dev/null 2>&1; then
            echo "tunnel_ready=true" >> $GITHUB_OUTPUT
            echo "âœ… Tunnel is ready for external access"
          else
            echo "tunnel_ready=false" >> $GITHUB_OUTPUT
            echo "âŒ Tunnel is not ready - build-and-push may fail"
            echo "Wrapper status:"
            if [ -f /tmp/pinggy.pid ] && kill -0 $(cat /tmp/pinggy.pid) 2>/dev/null; then
              echo "Wrapper is running (PID: $(cat /tmp/pinggy.pid))"
            else
              echo "Wrapper is not running"
            fi
            echo "Recent logs:"
            tail -10 /tmp/pinggy.log 2>/dev/null || echo "No tunnel logs available"
          fi

  build-and-push:
    runs-on: ubuntu-latest
    needs: [prepare-tag, setup-registry]
    outputs:
      tag: ${{ needs.prepare-tag.outputs.tag }}
    env:
      # Registry accessible from GitHub via nginx reverse proxy
      # Docker registry accessible via /v2/ path on the main domain
      REGISTRY_DOMAIN: 'r1.teamxagents.com'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/teamhub/Dockerfile
          push: false
          tags: |
            teamhub:latest
            teamhub:${{ needs.prepare-tag.outputs.tag }}
          outputs: type=docker,dest=/tmp/teamhub.tar

      - name: Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: teamhub-image
          path: /tmp/teamhub.tar
          retention-days: 1

      - name: Cache pnpm store
        uses: actions/cache@v4
        with:
          path: ~/.pnpm-store
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Test DNS and connectivity before login
        run: |
          echo "Testing DNS resolution for $REGISTRY_DOMAIN..."

          # Test DNS resolution
          if nslookup $REGISTRY_DOMAIN; then
            echo "âœ… DNS resolution successful"
          else
            echo "âŒ DNS resolution failed"
            exit 1
          fi

          # Test basic connectivity (HTTPS since Pinggy exposes port 443)
          echo "Testing basic connectivity to $REGISTRY_DOMAIN..."
          if curl -I --connect-timeout 10 --max-time 30 https://$REGISTRY_DOMAIN 2>/dev/null; then
            echo "âœ… HTTPS connection successful"
          else
            echo "âš ï¸ HTTPS connection failed, trying HTTP as fallback..."
            if curl -I --connect-timeout 10 --max-time 30 http://$REGISTRY_DOMAIN 2>/dev/null; then
              echo "âœ… HTTP connection successful (unexpected but working)"
            else
              echo "âŒ Both HTTPS and HTTP connections failed"
            fi
          fi

          # Test registry endpoint specifically (HTTPS first)
          echo "Testing registry endpoint /v2/..."
          if curl -I --connect-timeout 10 --max-time 30 https://$REGISTRY_DOMAIN/v2/ 2>/dev/null; then
            echo "âœ… Registry endpoint accessible via HTTPS"
          else
            echo "âš ï¸ Registry endpoint not accessible via HTTPS, trying HTTP..."
            if curl -I --connect-timeout 10 --max-time 30 http://$REGISTRY_DOMAIN/v2/ 2>/dev/null; then
              echo "âœ… Registry endpoint accessible via HTTP (unexpected but working)"
            else
              echo "âŒ Registry endpoint not accessible"
            fi
          fi

      - name: Login to external registry via Pinggy
        run: |
          echo "Logging in to registry at https://$REGISTRY_DOMAIN (Pinggy exposes HTTPS)"
          echo "k8mX9pL2nQ7vR4wE" | docker login https://$REGISTRY_DOMAIN -u docker --password-stdin

      - name: Load and push image to external registry
        run: |
          # Load the built image
          docker load -i /tmp/teamhub.tar

          # Tag for external registry
          docker tag teamhub:${{ needs.prepare-tag.outputs.tag }} $REGISTRY_DOMAIN/teamhub:${{ needs.prepare-tag.outputs.tag }}
          docker tag teamhub:latest $REGISTRY_DOMAIN/teamhub:latest

          # Push to external registry with retry logic
          for i in {1..3}; do
            echo "Pushing images to external registry (attempt $i/3)..."
            if docker push $REGISTRY_DOMAIN/teamhub:${{ needs.prepare-tag.outputs.tag }} && docker push $REGISTRY_DOMAIN/teamhub:latest; then
              echo "Successfully pushed images to external registry"
              break
            else
              echo "Push failed, retrying in 10 seconds..."
              sleep 10
              if [ $i -eq 3 ]; then
                echo "Failed to push after 3 attempts"
                exit 1
              fi
            fi
          done

  deploy:
    runs-on: self-hosted
    needs: build-and-push
    steps:
      - name: Checkout required files
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            docker-stack.yml
            nginx.conf
          sparse-checkout-cone-mode: false

      - name: Download Docker image artifact
        uses: actions/download-artifact@v4
        with:
          name: teamhub-image
          path: /tmp

      - name: Load Docker image
        run: docker load -i /tmp/teamhub.tar

      - name: Login to local registry
        run: |
          echo "Logging in to local registry at localhost:5000"
          echo "k8mX9pL2nQ7vR4wE" | docker login localhost:5000 -u docker --password-stdin

      - name: Tag and push to local registry
        run: |
          docker tag teamhub:${{ needs.build-and-push.outputs.tag }} localhost:5000/teamhub:${{ needs.build-and-push.outputs.tag }}
          docker tag teamhub:latest localhost:5000/teamhub:latest

          # Push with retry logic
          for i in {1..3}; do
            echo "Pushing images to registry (attempt $i/3)..."
            if docker push localhost:5000/teamhub:${{ needs.build-and-push.outputs.tag }} && docker push localhost:5000/teamhub:latest; then
              echo "Successfully pushed images to registry"
              break
            else
              echo "Push failed, retrying in 10 seconds..."
              sleep 10
              if [ $i -eq 3 ]; then
                echo "Failed to push after 3 attempts"
                exit 1
              fi
            fi
          done

      - name: Update docker-stack.yml with new image tag
        run: |
          sed -i "s|localhost:5000/teamhub:.*|localhost:5000/teamhub:${{ needs.build-and-push.outputs.tag }}|" docker-stack.yml

      - name: Deploy full application stack
        run: |
          echo "Deploying full application stack (including teamhub)..."
          export PG_PASSWORD="${{ secrets.PG_PASSWORD }}"

          # Check if we're transitioning from infrastructure-only to full stack
          USING_INFRA_CONFIG=false
          if docker config ls --filter name=teamhub_nginx_infra_config --format "{{.Name}}" | grep -q teamhub_nginx_infra_config; then
            echo "ðŸ”„ Transitioning from infrastructure-only to full stack deployment"
            USING_INFRA_CONFIG=true
          fi

                    # Use existing nginx.conf file for full configuration

          if [ "$USING_INFRA_CONFIG" = true ]; then
            # First deployment: transition from infrastructure to full stack
            echo "ðŸš€ First deployment: Transitioning to full stack with nginx.conf"

            # Update the docker-stack.yml to use file-based config instead of external
            sed -i 's/external: true/file: .\/nginx.conf/' docker-stack.yml
            sed -i 's/name: teamhub_nginx_config_v4//' docker-stack.yml

            # Deploy the full stack (nginx.conf is already checked out)
            export NEXTCLOUD_ADMIN_PASSWORD="${{ secrets.NEXTCLOUD_ADMIN_PASSWORD }}"
            export NEXTCLOUD_DB_PASSWORD="${{ secrets.NEXTCLOUD_DB_PASSWORD }}"
            docker stack deploy -c docker-stack.yml teamhub

            # Clean up the temporary infrastructure config after successful deployment
            echo "ðŸ§¹ Cleaning up temporary infrastructure config"
            sleep 30  # Wait for deployment to complete
            docker config rm teamhub_nginx_infra_config 2>/dev/null || true

          else
            # Subsequent deployments: just update the stack
            echo "ðŸ”„ Updating existing full stack deployment"
            export NEXTCLOUD_ADMIN_PASSWORD="${{ secrets.NEXTCLOUD_ADMIN_PASSWORD }}"
            export NEXTCLOUD_DB_PASSWORD="${{ secrets.NEXTCLOUD_DB_PASSWORD }}"
            docker stack deploy -c docker-stack.yml teamhub
          fi

          echo "Waiting for teamhub service to be ready..."
          sleep 30

      - name: Prune stopped containers
        run: docker container prune -f
